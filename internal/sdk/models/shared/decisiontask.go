// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-workflow/internal/sdk/internal/utils"
)

type LoopConfig struct {
	// The id of the branch that will be used to exit the loop
	ExitBranchID string `json:"exit_branch_id"`
	// The id of the branch that will be looped
	LoopBranchID string `json:"loop_branch_id"`
	// Maximum number of iterations for the loop branch
	MaxIterations *int64 `default:"3" json:"max_iterations"`
}

func (l LoopConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LoopConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"exit_branch_id", "loop_branch_id"}); err != nil {
		return err
	}
	return nil
}

func (l *LoopConfig) GetExitBranchID() string {
	if l == nil {
		return ""
	}
	return l.ExitBranchID
}

func (l *LoopConfig) GetLoopBranchID() string {
	if l == nil {
		return ""
	}
	return l.LoopBranchID
}

func (l *LoopConfig) GetMaxIterations() *int64 {
	if l == nil {
		return nil
	}
	return l.MaxIterations
}

type ScheduleType string

const (
	ScheduleTypeDelayedSchedule  ScheduleType = "DelayedSchedule"
	ScheduleTypeRelativeSchedule ScheduleType = "RelativeSchedule"
)

type Schedule struct {
	DelayedSchedule  *DelayedSchedule  `queryParam:"inline,name=schedule"`
	RelativeSchedule *RelativeSchedule `queryParam:"inline,name=schedule"`

	Type ScheduleType
}

func CreateScheduleDelayedSchedule(delayedSchedule DelayedSchedule) Schedule {
	typ := ScheduleTypeDelayedSchedule

	return Schedule{
		DelayedSchedule: &delayedSchedule,
		Type:            typ,
	}
}

func CreateScheduleRelativeSchedule(relativeSchedule RelativeSchedule) Schedule {
	typ := ScheduleTypeRelativeSchedule

	return Schedule{
		RelativeSchedule: &relativeSchedule,
		Type:             typ,
	}
}

func (u *Schedule) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var relativeSchedule RelativeSchedule = RelativeSchedule{}
	if err := utils.UnmarshalJSON(data, &relativeSchedule, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ScheduleTypeRelativeSchedule,
			Value: &relativeSchedule,
		})
	}

	var delayedSchedule DelayedSchedule = DelayedSchedule{}
	if err := utils.UnmarshalJSON(data, &delayedSchedule, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ScheduleTypeDelayedSchedule,
			Value: &delayedSchedule,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Schedule", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Schedule", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ScheduleType)
	switch best.Type {
	case ScheduleTypeRelativeSchedule:
		u.RelativeSchedule = best.Value.(*RelativeSchedule)
		return nil
	case ScheduleTypeDelayedSchedule:
		u.DelayedSchedule = best.Value.(*DelayedSchedule)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Schedule", string(data))
}

func (u Schedule) MarshalJSON() ([]byte, error) {
	if u.DelayedSchedule != nil {
		return utils.MarshalJSON(u.DelayedSchedule, "", true)
	}

	if u.RelativeSchedule != nil {
		return utils.MarshalJSON(u.RelativeSchedule, "", true)
	}

	return nil, errors.New("could not marshal union type Schedule: all fields are null")
}

type DecisionTask struct {
	AssignedTo []string    `json:"assigned_to,omitempty"`
	Conditions []Condition `json:"conditions"`
	// Longer information regarding Task
	Description *StepDescription `json:"description,omitempty"`
	DueDate     *string          `json:"due_date,omitempty"`
	// Set due date for the task based on a dynamic condition
	DueDateConfig *DueDateConfig `json:"due_date_config,omitempty"`
	// Details regarding ECP for the workflow step
	Ecp *ECPDetails `json:"ecp,omitempty"`
	ID  string      `json:"id"`
	// Details regarding ECP for the workflow step
	Installer  *ECPDetails  `json:"installer,omitempty"`
	Journey    *StepJourney `json:"journey,omitempty"`
	LoopConfig *LoopConfig  `json:"loop_config,omitempty"`
	Name       string       `json:"name"`
	PhaseID    *string      `json:"phase_id,omitempty"`
	// requirements that need to be fulfilled in order to enable the task while flow instances are running
	Requirements []EnableRequirement `json:"requirements,omitempty"`
	Schedule     *Schedule           `json:"schedule,omitempty"`
	TaskType     TaskType            `json:"task_type"`
	// Taxonomy ids that are associated with this workflow and used for filtering
	Taxonomies  []string    `json:"taxonomies,omitempty"`
	TriggerMode TriggerMode `json:"trigger_mode"`
}

func (d DecisionTask) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DecisionTask) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"conditions", "id", "name", "task_type", "trigger_mode"}); err != nil {
		return err
	}
	return nil
}

func (d *DecisionTask) GetAssignedTo() []string {
	if d == nil {
		return nil
	}
	return d.AssignedTo
}

func (d *DecisionTask) GetConditions() []Condition {
	if d == nil {
		return []Condition{}
	}
	return d.Conditions
}

func (d *DecisionTask) GetDescription() *StepDescription {
	if d == nil {
		return nil
	}
	return d.Description
}

func (d *DecisionTask) GetDueDate() *string {
	if d == nil {
		return nil
	}
	return d.DueDate
}

func (d *DecisionTask) GetDueDateConfig() *DueDateConfig {
	if d == nil {
		return nil
	}
	return d.DueDateConfig
}

func (d *DecisionTask) GetEcp() *ECPDetails {
	if d == nil {
		return nil
	}
	return d.Ecp
}

func (d *DecisionTask) GetID() string {
	if d == nil {
		return ""
	}
	return d.ID
}

func (d *DecisionTask) GetInstaller() *ECPDetails {
	if d == nil {
		return nil
	}
	return d.Installer
}

func (d *DecisionTask) GetJourney() *StepJourney {
	if d == nil {
		return nil
	}
	return d.Journey
}

func (d *DecisionTask) GetLoopConfig() *LoopConfig {
	if d == nil {
		return nil
	}
	return d.LoopConfig
}

func (d *DecisionTask) GetName() string {
	if d == nil {
		return ""
	}
	return d.Name
}

func (d *DecisionTask) GetPhaseID() *string {
	if d == nil {
		return nil
	}
	return d.PhaseID
}

func (d *DecisionTask) GetRequirements() []EnableRequirement {
	if d == nil {
		return nil
	}
	return d.Requirements
}

func (d *DecisionTask) GetSchedule() *Schedule {
	if d == nil {
		return nil
	}
	return d.Schedule
}

func (d *DecisionTask) GetTaskType() TaskType {
	if d == nil {
		return TaskType("")
	}
	return d.TaskType
}

func (d *DecisionTask) GetTaxonomies() []string {
	if d == nil {
		return nil
	}
	return d.Taxonomies
}

func (d *DecisionTask) GetTriggerMode() TriggerMode {
	if d == nil {
		return TriggerMode("")
	}
	return d.TriggerMode
}
