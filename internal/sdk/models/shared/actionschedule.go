// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-workflow/internal/sdk/internal/utils"
)

type ActionScheduleType string

const (
	ActionScheduleTypeImmediateSchedule ActionScheduleType = "ImmediateSchedule"
	ActionScheduleTypeDelayedSchedule   ActionScheduleType = "DelayedSchedule"
	ActionScheduleTypeRelativeSchedule  ActionScheduleType = "RelativeSchedule"
)

type ActionSchedule struct {
	ImmediateSchedule *ImmediateSchedule `queryParam:"inline,name=ActionSchedule"`
	DelayedSchedule   *DelayedSchedule   `queryParam:"inline,name=ActionSchedule"`
	RelativeSchedule  *RelativeSchedule  `queryParam:"inline,name=ActionSchedule"`

	Type ActionScheduleType
}

func CreateActionScheduleImmediateSchedule(immediateSchedule ImmediateSchedule) ActionSchedule {
	typ := ActionScheduleTypeImmediateSchedule

	return ActionSchedule{
		ImmediateSchedule: &immediateSchedule,
		Type:              typ,
	}
}

func CreateActionScheduleDelayedSchedule(delayedSchedule DelayedSchedule) ActionSchedule {
	typ := ActionScheduleTypeDelayedSchedule

	return ActionSchedule{
		DelayedSchedule: &delayedSchedule,
		Type:            typ,
	}
}

func CreateActionScheduleRelativeSchedule(relativeSchedule RelativeSchedule) ActionSchedule {
	typ := ActionScheduleTypeRelativeSchedule

	return ActionSchedule{
		RelativeSchedule: &relativeSchedule,
		Type:             typ,
	}
}

func (u *ActionSchedule) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var relativeSchedule RelativeSchedule = RelativeSchedule{}
	if err := utils.UnmarshalJSON(data, &relativeSchedule, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ActionScheduleTypeRelativeSchedule,
			Value: &relativeSchedule,
		})
	}

	var delayedSchedule DelayedSchedule = DelayedSchedule{}
	if err := utils.UnmarshalJSON(data, &delayedSchedule, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ActionScheduleTypeDelayedSchedule,
			Value: &delayedSchedule,
		})
	}

	var immediateSchedule ImmediateSchedule = ImmediateSchedule{}
	if err := utils.UnmarshalJSON(data, &immediateSchedule, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ActionScheduleTypeImmediateSchedule,
			Value: &immediateSchedule,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ActionSchedule", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ActionSchedule", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ActionScheduleType)
	switch best.Type {
	case ActionScheduleTypeRelativeSchedule:
		u.RelativeSchedule = best.Value.(*RelativeSchedule)
		return nil
	case ActionScheduleTypeDelayedSchedule:
		u.DelayedSchedule = best.Value.(*DelayedSchedule)
		return nil
	case ActionScheduleTypeImmediateSchedule:
		u.ImmediateSchedule = best.Value.(*ImmediateSchedule)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ActionSchedule", string(data))
}

func (u ActionSchedule) MarshalJSON() ([]byte, error) {
	if u.ImmediateSchedule != nil {
		return utils.MarshalJSON(u.ImmediateSchedule, "", true)
	}

	if u.DelayedSchedule != nil {
		return utils.MarshalJSON(u.DelayedSchedule, "", true)
	}

	if u.RelativeSchedule != nil {
		return utils.MarshalJSON(u.RelativeSchedule, "", true)
	}

	return nil, errors.New("could not marshal union type ActionSchedule: all fields are null")
}
